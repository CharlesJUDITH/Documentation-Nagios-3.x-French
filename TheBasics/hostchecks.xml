<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[
  <!ENTITY % all.entities SYSTEM "../all-entities.ent">
  %all.entities;
]
>
<chapter id="thebasics-hostchecks" xreflabel="Host Checks">
	<title>Host Checks</title>
	<section>
		<title>Introduction</title>
		<para>The basic workings of host checks are described here...</para>
	</section>
	<section>
		<title>When Are Host Checks Performed?</title>
		<para>Hosts are checked by the Nagios daemon:</para>
		<itemizedlist>
			<listitem>
				<para>At regular intervals, as defined by the check_interval and retry_interval options
				in your <link linkend="configuringnagios-objectdefinitions-host">host definitions</link>.</para>
			</listitem>
			<listitem>
				<para>On-demand when a service associated with the host changes state.</para>
			</listitem>
			<listitem>
				<para>On-demand as needed as part of the <link linkend="thebasics-networkreachability">host reachability</link> 
				logic.</para>
			</listitem>
			<listitem>
				<para>On-demand as needed for <link linkend="advancedtopics-dependencychecks">predictive host dependency checks</link>.</para>
			</listitem>
		</itemizedlist>
		<para>Regularly scheduled host checks are optional. If you set the check_interval option in your host definition to
		zero (0), Nagios will not perform checks of the hosts on a regular basis. It will, however, still perform on-demand
		checks of the host as needed for other parts of the monitoring logic.</para>
		<para>On-demand checks are made when a service associated with the host changes state because Nagios needs to know 
		whether the host has also changed state. Services that change state are often an indicator that the host may have 
		also changed state. For example, if Nagios detects that the &protocol-http; service associated with a host just changed from a 
		CRITICAL to an OK state, it may indicate that the host just recovered from a reboot and is now back up and running.</para>
		<para>On-demand checks of hosts are also made as part of the <link linkend="thebasics-networkreachability">host reachability</link> 
		logic. Nagios is designed to detect network outages as quickly as possible, and distinguish between DOWN and UNREACHABLE
		host states. These are very different states and can help an admin quickly locate the cause of a network outage.</para>
		<para>On-demand checks are also performed as part of the <link linkend="advancedtopics-dependencychecks">predictive host dependency check</link>
		logic. These checks help ensure that the dependency logic is as accurate as possible.</para>
	</section>
	<section>
		<title>Cached Host Checks</title>
		<para>The performance of on-demand host checks can be significantly improved by implementing the use of cached checks, which
		allow Nagios to forgo executing a host check if it determines a relatively recent check result will do instead. More
		information on cached checks can be found <link linkend="advancedtopics-cachedchecks">here</link>.</para>
	</section>
	<section>
		<title>Dependencies and Checks</title>
		<para>You can define <link linkend="configuringnagios-objectdefinitions-hostdependency">host execution dependencies</link> that 
		prevent Nagios from checking the status of a host depending on the state of one or more other hosts. More information on 
		dependencies can be found <link linkend="advancedtopics-dependencies">here</link>.</para>
	</section>
	<section>
		<title>Parallelization of Host Checks</title>
		<para>Scheduled host checks are run in parallel. When Nagios needs to run a scheduled host check, it will initiate the host
		check and then return to doing other work (running service checks, etc). The host check runs in a child process that was 
		fork()ed from the main Nagios daemon. When the host check has completed, the child process will inform the main Nagios 
		process (its parent) of the check results. The main Nagios process then handles the check results and takes appropriate 
		action (running event handlers, sending notifications, etc.).</para>
		<para>On-demand host checks are also run in parallel if needed. As mentioned earlier, Nagios can forgo the actual execution
		of an on-demand host check if it can use the cached results from a relatively recent host check.</para>
		<para>When Nagios processes the results of scheduled and on-demand host checks, it may initiate (secondary) checks of other 
		hosts. These checks can be initated for two reasons: <link linkend="advancedtopics-dependencychecks">predictive dependency checks</link> 
		and to determining the status of the host using the <link linkend="thebasics-networkreachability">network reachability</link> logic. 
		The secondary checks that are initiated are usually run in parallel. However, there is one big exception that you should be aware 
		of, as it can have negative effect on performance...</para>
		<note><para>Hosts which have their <varname>max_check_attempts</varname> value set to 1 can cause serious performance problems. The reason? If Nagios 
		needs to determine their true state using the <link linkend="thebasics-networkreachability">network reachability</link> logic (to 
		see if they're DOWN or UNREACHABLE), it will have to launch serial checks of all of the host's immediate parents. Just to 
		reiterate, those checks are run serially, rather than in parallel, so it can cause a big performance hit. For this reason, I 
		would recommend that you always use a value greater than 1 for the max_check_attempts directives in your host definitions.</para></note>
	</section>
	<section>
		<title>Host States</title>
		<para>Hosts that are checked can be in one of three different states:</para>
		<itemizedlist>
			<listitem>
				<para>UP</para>
			</listitem>
			<listitem>
				<para>DOWN</para>
			</listitem>
			<listitem>
				<para>UNREACHABLE</para>
			</listitem>
		</itemizedlist>
	</section>
	<section>
		<title>Host State Determination</title>
		<para>Host checks are performed by <link linkend="thebasics-plugins">plugins</link>, which can return a state of OK, WARNING, UNKNOWN, or CRITICAL. How does Nagios translate these plugin return codes into host states of UP, DOWN, or UNREACHABLE? Lets see...</para>
		<para>The table below shows how plugin return codes correspond with preliminary host states. Some post-processing (which is described later) is done which may then alter the final host state.</para>
		<informaltable frame="all">
			<tgroup cols="2">
				<thead>
					<row>
						<entry>
							<para>Plugin Result</para>
						</entry>
						<entry>
							<para>Preliminary Host State</para>
						</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<para>OK</para>
						</entry>
						<entry>
							<para>UP</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>WARNING</para>
						</entry>
						<entry>
							<para>UP or DOWN*</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>UNKNOWN</para>
						</entry>
						<entry>
							<para>DOWN</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>CRITICAL</para>
						</entry>
						<entry>
							<para>DOWN</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
		<note><para>WARNING results usually means the host is UP. However, WARNING results are interpreted to mean the
		host is DOWN if the <link linkend="configuringnagios-configmain-use_aggressive_host_checking">use_aggressive_host_checking</link> 
		option is enabled.</para>
		<para>If the preliminary host state is DOWN, Nagios will attempt to see if the host is really DOWN or if it is
		UNREACHABLE. The distinction between DOWN and UNREACHABLE host states is important, as it allows admins to determine
		root cause of network outages faster. The following table shows how Nagios makes a final state determination based 
		on the state of the hosts parent(s). A host's parents are defined in the parents directive in host definition.</para></note>
		<informaltable frame="all">
			<tgroup cols="3">
				<thead>
					<row>
						<entry>
							<para>Preliminary Host State</para>
						</entry>
						<entry>
							<para>Parent Host State</para>
						</entry>
						<entry>
							<para>Final Host State</para>
						</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<para>DOWN</para>
						</entry>
						<entry>
							<para>At least one parent is UP</para>
						</entry>
						<entry>
							<para>DOWN</para>
						</entry>
					</row>
					<row>
						<entry>
							<para>DOWN</para>
						</entry>
						<entry>
							<para>All parents are either DOWN or UNREACHABLE</para>
						</entry>
						<entry>
							<para>UNREACHABLE</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
		<para>More information on how Nagios distinguishes between DOWN and UNREACHABLE states can be found 
		<link linkend="thebasics-networkreachability">here</link>.</para>
	</section>
	<section>
		<title>Host State Changes</title>
		<para>As you are probably well aware, hosts don't always stay in one state. Things break, patches get 
		applied, and servers need to be rebooted. When Nagios checks the status of hosts, it will be able to detect 
		when a host changes between UP, DOWN, and UNREACHABLE states and take appropriate action. These state changes
		result in different <link linkend="thebasics-statetypes">state types</link> (HARD or SOFT), which can trigger 
		<link linkend="advancedtopics-eventhandlers">event handlers</link> to be run and
		<link linkend="thebasics-notifications">notifications</link> to be sent out. Detecting and dealing with 
		state changes is what Nagios is all about.</para>
		<para>When hosts change state too frequently they are considered to be <quote>flapping</quote>. A good example of a 
		flapping host would be server that keeps spontaneously rebooting as soon as the operating system loads. 
		That's always a fun scenario to have to deal with. Nagios can detect when hosts start flapping, and can 
		suppress notifications until flapping stops and the host's state stabilizes. More information on the flap 
		detection logic can be found <link linkend="advancedtopics-flapping">here</link>.</para>
	</section>
</chapter>

